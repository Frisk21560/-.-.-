// Homework 12.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#pragma region Programming Theory
// Програмування 
//  - процес створення ПЗ.
// Програмування складається з:
//  1. Аналіз задачі
//  2. Проєктування програмного коду
//  3. Написання коду
//  4. Пошук помилок
//  5. Оновлення та підтримка ПЗ
// Парадигма програмування
//  - стиль, підхід та набір прийомів до розробки ПЗ.
// Процедурне програмування
//  - парадигма програмування, яка вимагає виконання алгоритмичної декомпозиції.
// Алгоритмична декомпозиція
//  - розбиття задачі на малі алгоритми, які називаються процедурами або функціями.
// Структурне програмування
//  - різновид процедурного програмування, в якому ми об'єднуємо дані в структури та передаємо структури фукціям на обробку.
// ООП - об'єктно-орієнтоване програмування
//  - підхід (парадигма) до програмування, який будується на об'єктній декомпозиції.
// Об'єктна декомпозиція 
//  - визначення сутностей в програмі, їх характеристики та способи їх взаємодії між собою.
// Мета ООП: 
//  Абстракція - концентрація тільки на найважливішому і відкидання всього не суттєвого.
// Три принципи ООП:
//  1. Інкапсуляція
//      - об'єднання даних і способів їх обробки, при цьому приховуємо внутріншню реалізацію від решти програми та надаємо інтерфейс для
// взаємодії з цією внутрішнею реалізацією.
// Приклад з життя: 
//      Мікрохвильовка
//          - внутрішня реалізація роботи прихована
//          - кнопки, ричажкі і екран це інтерфейс для взаємодії з внутрішньої реалізацією.
// Приклад з C++:
//      Клас string
//          - внутрішня реалізація
//              - динамічний масив символів (char)
//              - виділення та звільнення пам'яті приховано (абстракція)
//          - інтерфейс
//              - набір методів для роботи з рядком (substr, replace тощо)
//              - перевантажені оператори (порівняння, +)
//  2. Спадкування (розширення)
//      - принцип який дозволяє створювати нові класи на основі існуюючих.
//      - принцип взаємодії об'єктів is-a (сутність А є підтипом сутності Б).
// Дві причини використання спадкування:
//  1) Уникнення дублювання коду (DRY принцип)
//      - класи-спадкоємці автоматично отримують всіх членів батьківського класу
//  2) Абстракція в рамках ієрархії
//      - визначення базової реалізації класів і абстракція від конкретної реалізації в клієнтському коді.
// Приклад з життя:
//  - базовий клас Їжа (БЖВ, нутрієнти, мікроелементи)
//      - похідні класи фрукти, овочі, консерви, напівфабрикати тощо
// Прикладний приклад:
//  - клас Character - базовий клас в відеоігрі (хп, ходьба)
//      - Scout, Bomber, Medic, Cannoneer - похідні класи конкретних юнітів, які розширюють базову логіку (власний вид атаки)
// Приклад з С++:
//  - клас exception (метод what, поле message)
//      - bad_cast, logic_error, runtime_error тощо - похідні класи
//  3. Поліморфізм
//      - принцип, який вимагає виконати різну реалізацію однієї задачі для різних даних через один інтерфейс.
//      - один інтерфейс - багато реалізацій.
// Види поліморфізму:
// 1) статичний - визначення конкретної реалізації відбувається на етапі компіляції
//      - перевантаження функцій
//          - створення функцій з однаковим іменем але різним набором параметрів
//      - перевантаження операторів
//          - визначення логіки роботи операторів для користувацьких типів
//      - перевантаження методів
//          - створення методів з однаквим іменем але різним набором параметрів
//      - шаблони функцій
//          - створення основи для автоматичної генерації функції компілятором для потрібних параметрів
//      - шаблони класів
//          - створення основи для автоматичної генерації класів компілятором для потрібних типів полів або параметрів методів.
// 2) динамічний - визначення конкретної реалізації відбувається на етапі виконання
//      - реалізується за допомогою перевизначення віртуальних методів базового класу в класах нащадках.
//      - покажчик (або посилання) на базовий клас і його метод - єдиний інтерфейс
//      - перевизначення методу в класах нащадках - багато реалізацій
//      - динамічність заключається в тому, що конкретна реалізація визначається на етапі виконання
// Віртуальні функції (або методи)
//  - функція базового класу, яку можна перевизначити в похідному класі.
//  - створюється за допомогою ключового слова virtual
// Чисто віртуальні функції
//  - це віртуальна функція, що не має власної реалізації.
//  - наявність такої фукнції в класі перетворює клас на абстрактний
// Абстрактні класи
//  - це класи, що не можуть мати власних екземплярів (об'єктів)
//  - створюються за допомогою чисто віртуальних функцій
// Інтерфейси
//  - контракт, який зобов'язуються виконати всі класи, що реалізують функціональність цього інтерфейсу
//  - в С++ інтерфейси реалузються як класи, що містять тільки чисто віртуальні функції
// Структури даних
//  - це різні способи зберігання та отримання доступу до даних в програмі.
// Масиви
//  - набір елементів одного типу, які зберігаються послідовно в пам'яті
//  - в C++ реалізується через покажчик на нульовий елемент.
//  - перевага: швидкий доступ до елементу по індексу
//      - формула: (адреса нульового елементу) + (розмір елементу) * (індекс)
//  - недолік: зміна розміру вимагає перевиділення пам'яті та копіювання елементів
// Список (List)
//  - набір елементів (вузлів), що містять значення та покажчик на наступний елемент.
//  - існують двозв'язні списки
//      - кожен елемент містить покажчик на наступний та попередній елемент.
//  - перевага: зміна розміру вимагає лише переназначення покажчиків без копіювання
//  - недолік: доступ до елементу за індексом вимагає перебору всіх елементів до цього індексу
// Черга
//  - структура даних, яка надає доступ до даних за принципом FIFO
//  - FIFO - first in, first out
// Різновиди черги 
//  - кільцева черга - елемент одразу повертається в кінець черги
//  - черга з пріоритетами - елементи з більшим пріоритетом раніше виходять з черги
// Стек
//  - структура даних, яка надає доступ до даних за принципом LIFO
//  - LIFO - last in, first out
//  - приклади: стек виклику функцій, історія дій (Ctrl + Z)
// Композиція
//  - вид взаємодії між об'єктами has-a.
//  - сильне володіння
//  - один об'єкт складається з інших
//  - цикл життя об'єктів міцно пов'язаний
//      - головний об'єкт створюється разом з внутрішніми об'єктами
//      - внутрішні об'єкти знищуються разом з головним об'єктом
// Приклад:
//  - людина і її органи
//      - органи створюються разом з людиною
//      - органи знищуються разом з людиною
// Приклад з C++:
//  - клас string
//      - об'єкт класу string не може існувати без покажчика char*
// Прикладний приклад:
//  - об'єкт гравця (Player)
//      - містить посилання на свої компоненти ігрового об'єкту
// Агрегація
//  - вид взаємодії між об'єктами has-a.
//  - слабке володіння об'єктом
//  - один об'єкт містить в собі інший, але не складається з нього
//  - цикл життя об'єктів не залежить один від одного
//      - головний об'єкт і внутрішній можуть створюватись окремо
//      - головний об'єкт і внутрішній знищуються окремо
// Приклад:
//  - Група - Студенти
// Прикладний приклад:
//  - Клас Group
//  - Клас User
#pragma endregion


// Компілятор
//  - програма, що компілює код.
// Компіляція
//  - це попередній переклад коду мовою програмування на машинний код.
// Інтерпретатор
//  - програма, що інтерперетує код.
// Інтерпретація
//  - послідовний переклад інструкцій на машинний код і їх виконання.
//  - виконання кожної інструкції відбувається одразу після перекладу
//  - не відбувається попереднього перекладу всієї програми на машинний код.
// Лексеми
//  - найменшою неділимою одиницею мови програмування, яку може розрізнити компілятор
// Лексеми поділяються на:
//  - ключові слова (int, float, if, while тощо)
//  - оператори (+ - / . -> тощо)
//      - операнд - те над чим оператор проводить операцію
//  - літерали (значення, що вказані в коді)
//  - ідентифікатори (імена змінних, функцій, класів, структур тощо)
//      - латинські літери
//      - цифри (але не першим символом)
//      - нижнє підкреслення (_)
//  - розділові знаки ({})
// Змінна
//  - це іменована область пам'яті, що зберігає дані певного типу і може змінювати ці дані
// протягом виконання програми.
// Константа 
//  - це іменована область пам'яті, що зберігає дані певного типу і НЕ може змінювати ці дані 
// протягом виконання програми.ї
// Тип даних
//  - характеристика даних, яка визначає 
//      1) діапазон значень, що можуть зберігатись
//      2) оператори доступні для роботи з цими даними
// Умовні конструкції
//  - конструкція мови програмування яка дозволяє виконувати різні дії в залежності від
// деякої умови. 
//  - if-elseif-else, switch, ?:
// Циклічні конструкції
//  - конструкція мови програмування яка дозволяє виконувати деякі дії певну кількість разів
// в залежності від умови.
//  - while, do-while, for, for(each)
// Функції 
//  - іменований набір інструкцій, який можна викликати та перевикористовувати в програмі.
// Лямбда-функція
//  - це спеціальна анонімна функція, яка не має імені і використовується "на місці".
// Препроцесор
//  - програма, що обробляє код перед компіляцією та виконує директиви.
// Директиви препроцесора
//  - спеціальні команди, які виконує препроцесор.
// Приклад:
//  - define
//  - include
//  - pragma
//      - once
//      - region
// Кодування символів
//  - базовий тип char використовує 1 байт (8 біт) - 2^8 комбінацій 0 та 1 - 256 (0-255)
// 0000.0000
//  - ASCII використовує 7 біт 2^7 - 128 символів (0-127)
//  - розширена таблиця ASCII використовує 8 біт 2^8 - 256 символів
//      - має декілька версій 
//          - windows 1251 - кирилиця
//          - windowd 1252 - центрально та східно єврпоейські латинські символи
//  - Unicode
//      - UTF-8 використовує 1 байт - 256 символів
//      - UTF-16 використовує 2 байти - 16 біт - 2^16 = 65.536 символів
//      - UTF-32 використовує 4 байти - 32 біти - 2^32 = 4.294.967.286 символів
// Покажчики
//  - це спеціальна змінна, що зберігає адресу в оперативній пам'яті.
// Посилання
//  - це друге ім'я (псевдонім) для змінної.
// Способи передачі параметрів у функцію:
//  1) за значенням
//      - фукнція працює з копією
//  2) за адресою
//      - функція працює з копією покажчика, через який має доступ до оригіналу
//  3) за посиланням
//      - функція працює з оригінальною змінною


// Дописати наступні пункти :

// Класи, об'єкти
//  - клас
//    - це шаблон (тип), який описує дані (поля) і поведінку (методи).
//    - приклад: class Person { public: string name; void say() {...} };
//  - об'єкт
//    - екземпляр класу, має конкретні значення полів.
//    - приклад: Person p; p.name = "Ivan";
//  - відмінності: клас - опис, об'єкт - реалізація в пам'яті.
//  - члени класу: поля (змінні-члени), методи (функції-члени), статичні члени, вкладені типи.

// Конструктор, деструктор
//  - конструктор: спеціальна функція для ініціалізації об'єкта.
//    - види: конструктор за замовчуванням, параметризований, конструктор копіювання, конструктор перенесення.
//    - ініціалізатор (initializer list): Class(): field(val) {} - кращий спосіб ініціалізації членів.
//    - приклад:
//        class Foo {
//        public:
//          int x;
//          Foo(): x(0) {}                // конструктор за замовчуванням
//          Foo(int a): x(a) {}          // параметризований
//        };
//  - деструктор: ~ClassName() - викликається при знищенні об'єкта, звільняє ресурси.
//    - якщо клас володіє ресурсами (new, файли), деструктор мусить їх звільнити.
//    - якщо клас віртуальний базовий, деструктор повинен бути віртуальним.

// Потоки (streams)
//  - iostream: для роботи з консоллю: std::cin, std::cout, std::cerr.
//    - оператори >> для вводу, << для виводу.
//  - файлові потоки: std::ifstream (читання), std::ofstream (запис), std::fstream (обидва).
//    - приклад:
//        std::ofstream f("out.txt");
//        if (f) f << "Hello\n";
//        f.close();
//  - перевірка стану: if (f) або f.is_open(), f.fail() ...
//  - корисно закривати файли або використовувати RAII (файловий потік закриється в деструкторі).

// Покажчик this
//  - внутрішній покажчик у методі класу, вказує на поточний об'єкт.
//  - тип: ClassName* this; або у константному методі const ClassName* this.
//  - приклади використання:
//      - доступ до полів коли є імена-конфлікти: this->x = x;
//      - повернення *this для ланцюжка викликів: return *this;
//  - у const методі this має тип const ClassName* - не можна змінювати члени.

// Перетворення типів в C++
//  - неявні перетворення: компілятор може автоматично перетворити одні типи в інші (наприклад, int -> double).
//  - явні (C-style): (Type)x або Type(x) - не безпечні, краще уникати.
//  - C++-касти:
//      - static_cast<T>(expr) - для перевірених конверсій між сумісними типами.
//      - dynamic_cast<T*>(expr) - для безпечного приведення в ієрархії з поліморфізмом (повертає nullptr якщо не вдається).
//      - reinterpret_cast<T>(expr) - небезпечне приведення бітового представлення.
//      - const_cast<T>(expr) - змінює/знімає const/volatile.
//  - правило: використовувати найбезпечніший каст, уникати reinterpret_cast, не зловживати const_cast.

// Константні методи
//  - синтаксис: ReturnType func() const { ... }
//  - означає, що метод не змінює стан об'єкта (не змінює нестатичні поля).
//  - дозволяє викликати метод на const об'єкті.
//  - приклад:
//      class P { int x; public: int get() const { return x; } };
//  - this всередині const методу має тип const ClassName*.

// Винятки (class exception)
//  - механізм для обробки помилок: throw, try, catch.
//  - стандартні класи: std::exception, std::runtime_error, std::logic_error тощо.
//  - приклад:
//      try {
//        if (error) throw std::runtime_error("bad");
//      } catch (const std::exception& e) {
//        std::cerr << e.what();
//      }
//  - stack unwinding: при виключенні викликаються деструктори тимчасових об'єктів та локальних змінних.
//  - catch(...) - ловить будь-який тип виключення (використовувати обережно).
//  - кращі практики: кидати/ловити об'єкти, які наслідують від std::exception; не використовувати винятки для контролю потоку.

// Перевантаження операторів
//  - дозволяє визначити поведінку операторів для користувацьких типів.
//  - синтаксис:
//      class A {
//      public:
//        A operator+(const A& o) const { A r; ... return r; } // як метод
//        friend std::ostream& operator<<(std::ostream& os, const A& a) { ... } // дружня функція
//      };
//  - правила:
//      - деякі оператори обов'язково мають бути методами (наприклад, operator=, operator[], operator(), operator->).
//      - арифметичні оператори часто повертають новий об'єкт (можна повертати за значенням).
//      - оператор присвоєння повинен повертати *this за посиланням (Class& operator=(...)) для ланцюжка.
//      - префіксний і постфіксний ++ відрізняються сигнатурами:
//          Class& operator++()   // префікс
//          Class operator++(int) // постфікс, int - маркер
//  - коли використовувати: для зрозумілого й природнього синтаксису роботи з типами.

// Семантика переміщення (move semantics)
//  - move constructor: Class(Class&& other) - переносить ресурси від other до нового об'єкта.
//  - move assignment: Class& operator=(Class&& other) - аналогічно для присвоєння.
//  - std::move(expr) - приводить lvalue до rvalue, щоб викликати перенесення.
//  - після перенесення об'єкт-джерело має бути в коректному, але невизначеному стані (часто "порожньому").
//  - мета: уникнути дорогої копії (наприклад, при роботі з векторами, рядками), покращити продуктивність.
//  - приклад:
//      class Buffer { int* p; size_t n; public:
//        Buffer(Buffer&& b): p(b.p), n(b.n) { b.p = nullptr; b.n = 0; }
//      };

// Семантика копіювання
//  - copy constructor: Class(const Class& other) - створює копію.
//  - copy assignment: Class& operator=(const Class& other) - присвоєння копією.
//  - shallow copy vs deep copy:
//      - shallow: копіюється лише вказівники (може призвести до подвійного видалення).
//      - deep: копіюються самі ресурси (новий буфер, нові дані).
//  - правило трьох/п'яти/нуль:
//      - якщо клас керує ресурсами і ви пишете деструктор, копіювальний конструктор або оператор присвоєння — напишіть усі три (rule of three).
//      - із move-операціями додається rule of five.
//      - краще використовувати механізми RAII/розумні покажчики і не писати нічого (rule of zero).

// Розумні покажчики
//  - std::unique_ptr<T> - унікальний власник ресурсу, не копіюється, можна переносити.
//    - приклад: auto p = std::make_unique<int>(5);
//  - std::shared_ptr<T> - спільна власність, лічильник посилань, ресурс видаляється коли лічильник = 0.
//    - приклад: auto s = std::make_shared<My>(); auto s2 = s; // лічильник +1
//  - std::weak_ptr<T> - неблокуюче посилання на ресурс, який контролюється shared_ptr (не збільшує лічильник).
//    - використовується щоб уникнути циклічних посилань між shared_ptr.
//  - переваги: автоматичне звільнення ресурсів, безпечніше ніж сирі вказівники.
//  - використання: unique_ptr коли є один власник, shared_ptr коли потрібна спільна власність.

// STL (Standard Template Library)
//  - базові частини: контейнері (vector, list, deque, map, unordered_map, set ...), ітератори, алгоритми, функтори/лямбди.
//  - мета: стандартний набір перевірених структур і алгоритмів, що економить час і мінімізує помилки.
//  - приклади алгоритмів: std::sort, std::find, std::for_each, std::accumulate.
//  - ітератори дають узагальнений доступ до елементів контейнерів (подібно до вказівника).
//  - лямбда-функції: компактний спосіб передати функцію в алгоритм:
//      std::sort(v.begin(), v.end(), [](int a,int b){ return a<b; });

// Дружні функції
//  - friend function: може доступатись до приватних і захищених членів класу.
//  - синтаксис: friend ReturnType func(...);
//  - використання: часто для операторів вводу/виводу (operator<<), або для функцій, які логічно не є методами класу.
//  - зауваження: дружні функції порушують інкапсуляцію, тому їх використовують обережно.

// Статичні члени класу
//  - static змінна-член: спільна для всіх екземплярів класу.
//    - оголошується всередині класу, визначається (ініціалізується) поза класом: Type Class::member = val;
//    - приклад: static int count; // рахує кількість створених об'єктів
//  - static функція-член: не має this, може звертатись тільки до статичних членів.
//    - викликається як Class::func() або через об'єкт.

// explicit конструктор
//  - ключове слово explicit перед конструктором забороняє неявні перетворення.
//  - приклад:
//      class A { public: explicit A(int x) {} };
//      A a = 3; // помилка, неявне перетворення заборонено
//      A b(3);  // ок
//  - використовується щоб уникнути небажаних неявних конверсій.

// Системи контролю версій
//  - приклад: Git - система контролю версій (VCS).
//  - основні операції: git init, git add, git commit, git branch, git checkout, git merge, git pull, git push.
//  - віддалені репозиторії: origin, remote (GitHub, GitLab).
//  - гілки (branches) дозволяють паралельно працювати над фичами.
//  - .gitignore використовується для виключення файлів з контролю версій.
//  - добре: писати маленькі зрозумілі коміти, використовувати pull requests для рев'ю.

// Шаблони класів (class templates)
//  - дозволяють писати узагальнений код для різних типів.
//  - синтаксис:
//      template<typename T>
//      class Box {
//        T val;
//      public:
//        Box(T v): val(v) {}
//        T get() const { return val; }
//      };
//  - інстанціація: Box<int> b(5);
//  - повна спеціалізація: template<> class Box<char*> { ... } - спеціальна реалізація для конкретного типу.
//  - часткова спеціалізація: застосовується для шаблонів класів (не для функцій), наприклад шаблон для вказівників.
//  - шаблони з варіативною кількістю аргументів (variadic templates): template<typename... Args> class Tuple { ... }.
//  - призначення: створювати повторно використовуваний код для різних типів без дублювання.


