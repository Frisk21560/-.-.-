// Homework 11.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <utility> // для pair
#include <cstdlib> // для rand, srand
#include <ctime>   // для time
#include <windows.h>

int main()
{
    SetConsoleOutputCP(1251);
    using namespace std;

    // пул питань і відповідей
    vector<pair<string, string>> pool = {
        { "1. Поясніть причини виникнення об'єктно-орієнтованого програмування.",
          "Причини: зростання складності програм, потреба моделювати реальні об'єкти, повторне використання коду та простіший супровід. OOP дає класи, інкапсуляцію, успадкування, поліморфізм." },

        { "2. Які переваги та недоліки має об'єктно-орієнтований підхід?",
          "Переваги: модульність, інкапсуляція, повторне використання, легке розширення. Недоліки: іноді складність, накладні витрати на абстракції, ризик поганої ієрархії." },

        { "3. Що таке інкапсуляція? Наведіть приклади з реального життя.",
          "Інкапсуляція — приховування внутрішніх даних і реалізації за інтерфейсом. Приклад: автомобіль (водій не бачить двигун), банківський рахунок (операції через методи deposit/withdraw)." },

        { "4. Що таке абстракція? Наведіть приклади з реального життя.",
          "Абстракція — виділення важливих рис і відкидання деталей. Приклад: кермо/педалі в авто, інтерфейс телефона (іконки), меню програми." },

        { "5. Що таке поліморфізм? Наведіть приклади з реального життя.",
          "Поліморфізм — одна операція, різна поведінка для різних типів. Приклад: метод draw() для різних фігур, одна кнопка у різних режимах робить різне." },

        { "6. Що таке успадкування? Наведіть приклади з реального життя.",
          "Успадкування — створення нового класу на основі існуючого, повторне використання коду. Приклад: Транспорт -> Автомобіль/Велосипед; Тварина -> Собака/Кіт." },

        { "7. Що таке клас і об'єкт? У чому різниця?",
          "Клас — шаблон (тип) з полями й методами. Об'єкт — екземпляр класу з конкретними значеннями. Клас описує, об'єкт реалізує." },

        { "8. Які цілі специфікаторів доступу (public/private/protected)?",
          "public — доступ звідусіль, private — тільки всередині класу (і друзів), protected — всередині класу і його нащадків. Мета: контроль доступу і захист інваріантів." },

        { "9. Що таке конструктор і його мета?",
          "Конструктор — функція для ініціалізації об'єкта при створенні. Мета: встановити початковий коректний стан і виділити ресурси при потребі." },

        { "10. Що таке деструктор і його мета?",
          "Деструктор — функція, що викликається при знищенні об'єкта. Мета: звільнити ресурси (пам'ять, файли), очистити стан (RAII)." },

        { "11. Що таке конструктор копіювання? Його мета?",
          "Конструктор копіювання (Class(const Class&)) створює об'єкт як копію іншого. Мета: правильно копіювати дані та ресурси (глибока копія при потребі)." },

        { "12. Що таке конструктор перенесення? Для чого потрібен?",
          "Конструктор перенесення (Class(Class&&)) переміщує ресурси з тимчасового об'єкта у новий без дорогої копії. Мета: оптимізація (ефективне повернення значень, робота з контейнерами)." },

        { "13. Що таке віртуальна функція? Яку задачу вирішує?",
          "Віртуальна функція дозволяє похідним класам перевизначати поведінку; виклик через базовий вказівник вибирає реалізацію конкретного об'єкта (динамічний поліморфізм)." },

        { "14. Що таке віртуальний деструктор і навіщо він потрібен?",
          "Віртуальний деструктор потрібен, коли об'єкти видаляють через вказівник на базовий клас; гарантує виклик деструкторів похідних класів і правильне звільнення ресурсів." },

        { "15. Що таке шаблонний клас (template)? В чому його сенс?",
          "Шаблонний клас параметризує типи (template<typename T>), дозволяє створювати один код для багатьох типів, уникати дублювання коду (наприклад, std::vector<T>)." },

        { "16. Що таке розумний покажчик? Коли його використовувати?",
          "Розумний покажчик (unique_ptr, shared_ptr) автоматично управляє життєвим циклом пам'яті. Використовують для безпечного управління динамічною пам'яттю, щоб уникнути витоків." },

        { "17. Чим відрізняються auto_ptr, unique_ptr, shared_ptr?",
          "auto_ptr — застарілий, небезпечний (копіювання переміщало власність). unique_ptr — унікальна власність (тільки move). shared_ptr — розділена власність з лічильником посилань." },

        { "18. Чому виник STL? Які його цілі?",
          "STL створили для стандартизованих контейнерів, ітераторів і алгоритмів: повторне використання, ефективність, узгоджений інтерфейс і швидка розробка." },

        { "19. Що таке контейнер? Наведіть приклади і їх цілі.",
          "Контейнер — структура для зберігання набору об'єктів (vector, list, map). Мета: організувати зберігання, доступ, вставку/видалення, оптимізовані під різні оперції." },

        { "20. В чому відмінність vector, list, map, multimap?",
          "vector — динам. масив, швидкий доступ по індексу; list — двозв'язний список, швидкі вставки/видалення в середині; map — дерево ключ->значення, унікальні ключі; multimap — як map, але допускає повтори ключів." }
    };

    // перевіряю, що пул має саме 20 елементів
    int n = (int)pool.size(); // n = 20
    if (n < 20) {
        cout << "В пулі менше 20 питань, потрібно 20.\n";
        return 1;
    }

    // seed для rand
    srand((unsigned)time(NULL)); // даю насіння для випадковості

    // індекси 0..n-1
    vector<int> idx;
    for (int i = 0; i < n; ++i) idx.push_back(i); // заповню індекси

    for (int i = n - 1; i > 0; --i) {
        int j = rand() % (i + 1); // випадковий j в [0..i]
        int tmp = idx[i]; idx[i] = idx[j]; idx[j] = tmp; // міняю місцями
    }

    // Візьму перші 20 випадкова перестановка
    vector<pair<string, string>> selected;
    for (int i = 0; i < 20; ++i) {
        selected.push_back(pool[idx[i]]); // додаю пару питання->відповідь
    }

    // відкриваю файли для запису: тільки питання і питання+відповіді
    ofstream fq("selected_questions.txt"); // тут тільки питання
    ofstream fa("selected_with_answers.txt"); // тут питання + відповіді
    if (!fq || !fa) {
        cout << "Не можу відкрити вихідні файли для запису.\n";
        return 1;
    }

    // записую заголовки у файли
    fq << "Вибрані випадкові питання (20):\n\n";
    fa << "Вибрані питання з відповідями (20):\n\n";

    // записую в файли і одночасно в консоль
    for (int i = 0; i < 20; ++i) {
        string q = selected[i].first;  // питання
        string a = selected[i].second; // відповідь

        // запис у файл тільки питання
        fq << (i + 1) << ". " << q << "\n\n";

        // запис у файл питання + відповідь
        fa << (i + 1) << ". " << q << "\n";
        fa << "Відповідь: " << a << "\n\n";

        // виводжу в консоль
        cout << (i + 1) << ". " << q << "\n";
        cout << "Відповідь: " << a << "\n\n";
    }

    fq.close();
    fa.close();

    cout << "Готово. Питання записані в selected_questions.txt, питання+відповіді в selected_with_answers.txt\n";

    return 0;
}
